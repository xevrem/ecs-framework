{
  "version": 3,
  "sources": ["../src/Bag.ts", "../src/Component.ts", "../src/ComponentManager.ts", "../src/ComponentMapper.ts", "../src/Entity.ts", "../src/EntityManager.ts", "../src/SystemManager.ts", "../src/TagManager.ts", "../src/GroupManager.ts", "../src/Scheduler.ts", "../src/utils.ts", "../src/EntityBuilder.ts", "../src/FuncQuery.ts", "../src/EcsInstance.ts", "../src/Query.ts", "../src/EntitySystem.ts"],
  "sourcesContent": ["\nexport class Bag<T> {\n  private _data: Array<Option<T>> = [];\n  private _length = 0;\n  private _count = 0;\n  private _last = -1;\n  private _invalidated = true;\n\n  constructor(capacity = 16) {\n    this._data = new Array<Option<T>>(capacity);\n    this._length = 0;\n  }\n\n  /**\n   * iterator symbol for Bags\n   */\n  [Symbol.iterator]() {\n    let i = 0;\n    const next = (): { value: T; done: boolean } => {\n      const value = this._data[i++];\n      return value\n        ? {\n            value,\n            done: i >= this._length,\n          }\n        : next();\n    };\n    return {\n      next,\n    };\n  }\n\n  iter() {\n    return this[Symbol.iterator];\n  }\n\n  /**\n   * total number indicies the bag contains\n   */\n  get capacity(): number {\n    return this._data.length;\n  }\n\n  /**\n   * are there any populated indexes in this bag\n   */\n  get isEmpty(): boolean {\n    return this._length === 0;\n  }\n\n  /**\n   * the furthest populated index in this bag\n   */\n  get length(): number {\n    return this._length;\n  }\n\n  /**\n   * the current count of non-undefined data elements\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * the base data structure of the bag\n   */\n  get data(): Array<Option<T>> {\n    return this._data;\n  }\n\n  lastIndex(start: number): number {\n    if (this._last !== -1 && !this._invalidated) return this._last;\n    for (let i = start; i--; ) {\n      if (this._data[i]) {\n        this._last = i;\n        this._invalidated = false;\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * return the last populated item\n   */\n  get last(): Option<T> {\n    return this._data[this.lastIndex(this._data.length)];\n  }\n\n  /**\n   * return the first item\n   */\n  get first(): Option<T> {\n    const size = this._data.length;\n    for (let i = 0; i < size; i++) {\n      const item = this.get(i);\n      if (item) return item;\n    }\n    return undefined;\n  }\n\n  /**\n   * perform a functional `forEach` operation on this bag\n   * @param args args the standard `forEach` arguments\n   * @param [context] the optional context to use\n   */\n  forEach(\n    args: (item: Option<T>, index: number, array: Array<Option<T>>) => void,\n    context?: Bag<T>\n  ): void {\n    return this._data.forEach(args, context);\n  }\n\n  /**\n   * perform a functional `map` operation on this bag\n   * @param args args the standard `map` arguments\n   * @param [context] the optional context to use\n   * @returns the results of the `map` operation\n   */\n  map(\n    args: (\n      item: Option<T>,\n      index: number,\n      array: Array<Option<T>>\n    ) => Option<T>,\n    context?: Bag<T>\n  ): Array<Option<T>> {\n    return this._data.map(args, context);\n  }\n\n  /**\n   * perform a functional `filter` operation on this bag\n   * @param args args the standard `filter` arguments\n   * @param [context] the optional context to use\n   * @returns the results of the `filter` operation\n   */\n  filter(\n    args: (item: Option<T>, index: number, array: Array<Option<T>>) => boolean,\n    context?: Bag<T>\n  ): Array<Option<T>> {\n    return this._data.filter(args, context);\n  }\n\n  /**\n   * perform a functional `reduce` operation on this bag\n   * @param args args the standard `reduce` arguments\n   * @param init the optional context to use\n   * @returns the results of the `reduce` operation\n   */\n  reduce<V>(\n    args: (\n      acc: V,\n      item: Option<T>,\n      index: number,\n      array: Array<Option<T>>\n    ) => V,\n    init: V\n  ): V {\n    return this._data.reduce(args, init);\n  }\n\n  /**\n   * perform a functional `slice` operation on this bag\n   * @param start the standard `slice` arguments\n   * @param end the optional context to use\n   * @returns the results of the `slice` operation\n   */\n  slice(start?: number, end?: number): Array<Option<T>> {\n    return this._data.slice(start, end);\n  }\n\n  some(\n    predicate: (\n      value: Option<T>,\n      index: number,\n      array: Array<Option<T>>\n    ) => boolean\n  ): boolean {\n    return this._data.some(predicate);\n  }\n\n  /**\n   * gets the item at the specified index\n   * @param index the index of the item to retrieve\n   * @returns the item if found otherwise `undefined`\n   */\n  get<U extends T>(index: number): Option<U> {\n    return this._data[index] as U;\n  }\n\n  /**\n   * sets the index to the given value. grows the bag if index exceeds capacity.\n   * @param index the index to set\n   * @param value the value to set\n   * @returns a copy of the value if successfully inserted, otherwise `undefined`\n   */\n  set(index: number, value: Option<T>): Option<T> {\n    if (index < 0) {\n      return undefined;\n    }\n    if (index >= this._data.length) {\n      this.grow(index * 2);\n    }\n    // IF we are setting a valid value larger than the current index\n    // THEN update our length\n    if (index >= this._length && value) {\n      this._length = index + 1;\n    } else if (\n      // IF we already are the furthest item\n      index === this._length - 1 &&\n      // AND we're unassignining it\n      !value\n    ) {\n      // THEN get the furthest index lower than ours\n      const last = this.lastIndex(index);\n      if (last === index) {\n        // throw an error if for whatever reason we get our index as the last\n        // even though we are \"unset\"-ing ourself\n        throw new Error('Last Index Invalid');\n      } else {\n        this._length = last + 1;\n      }\n    }\n\n    if (!this._data[index] && value) this._count += 1;\n    if (this._data[index] && !value) this._count -= 1;\n    if (index > this._last) this._last = index;\n    this._data[index] = value;\n    return value;\n  }\n\n  /**\n   * adds the given element to the end of the bags contents\n   * @param element the element to add\n   */\n  add(element: Option<T>): number {\n    if (this._length >= this._data.length) {\n      this.grow();\n    }\n    const index = this._length;\n    this._data[this._length] = element;\n    this._length++;\n    this._count += 1;\n    if (index > this._last) this._last = index;\n    return index;\n  }\n\n  /**\n   * adds the given bag to this one\n   * @param bag the bad to add\n   */\n  addBag(bag: Bag<T>): void {\n    for (let i = 0; bag.length > i; i++) {\n      this.add(bag.get(i));\n    }\n  }\n\n  /**\n   * sets each defined item of the bag into this one\n   * @param bag - the bag to set with\n   */\n  setBag(bag: Bag<T>): void {\n    for (let i = bag.length; i--; ) {\n      const item = bag.get(i);\n      // only set the item if it exists\n      item && this.set(i, item);\n    }\n    this._invalidated = true;\n  }\n\n  /**\n   * clears the contents of the bag\n   */\n  clear(): void {\n    this._data = new Array(this._data.length);\n    this._length = 0;\n    this._count = 0;\n  }\n\n  /**\n   * checks if an element with the given id is populated\n   */\n  has(id: number): boolean {\n    if (id < 0 || id > this._length) return false;\n    return !!this._data[id];\n  }\n\n  /**\n   * checks if the bag contains the given element\n   * @param element the element to check\n   * @param [compare] the optional comparator function to use\n   * @returns `true` if found, `false` if not\n   */\n  contains(element: T, compare = (a: T, b: Option<T>) => a === b): boolean {\n    for (let i = this._length; i--; ) {\n      if (compare(element, this._data[i])) return true;\n    }\n    return false;\n  }\n\n  /**\n   * check if an element exists within the bag via strict equals\n   * @param element the element to check\n   * @param fromIndex the optional starting index\n   * @returns `true` if found, `false` if not\n   */\n  includes(element: T, fromIndex = 0): boolean {\n    return this._data.includes(element, fromIndex);\n  }\n\n  /**\n   * removes the specified element from the bag\n   * @param element the element to remove\n   * @returns the element removed or `undefined` if no element was found\n   */\n  remove(element: T): Option<T> {\n    const index = this._data.indexOf(element);\n    if (index === this._last) this._invalidated = true;\n    return this.removeAt(index);\n  }\n\n  /**\n   * removes the element at the specified index\n   * @param index the index for the element to remove\n   * @returns the removed element or `undefined` if it was empty or out of bounds\n   */\n  removeAt(index: number): Option<T> {\n    if (index < this._data.length && index >= 0) {\n      const item = this._data[index];\n      this.set(index, undefined);\n      if (this._length < 0) this._length = 0;\n      return item;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * remove the element in the last filled position\n   * @returns the element if found or `undefined` if not\n   */\n  removeLast(): Option<T> {\n    const index = this._length - 1;\n    const item = this._data[index];\n    this.set(index, undefined);\n    if (this._length < 0) this._length = 0;\n    this._invalidated = true;\n    return item;\n  }\n\n  /**\n   * grow the bag to the specified size, so long as it is larger.\n   * @param size the size to grow the bag\n   */\n  grow(size: number = 2 * this._data.length + 1): void {\n    if (size <= this._data.length) return;\n    this._data = this._data.concat(\n      new Array<Option<T>>(size - this._data.length)\n    );\n  }\n}\n", "export const ComponentSymbol: unique symbol = Symbol('Component');\n\nexport class Component implements Component {\n  static type = -1;\n  owner = -1;\n\n  /**\n   * this allows us to interogate a type to see if it is a component type\n   * @returns whether type is a type of Component\n   */\n  static get [ComponentSymbol](): boolean {\n    return true;\n  }\n\n  /**\n   * this allows us to interogate an object to see if it is a component\n   * @returns whether an object is a Component\n   */\n  get [ComponentSymbol](): boolean {\n    return true;\n  }\n\n  /**\n   * get the registerd type of this component\n   */\n  get type(): number {\n    const inst = this.constructor as typeof Component;\n    return inst.type;\n  }\n  /**\n   * set the type number for all components of this type\n   */\n  set type(value: number) {\n    const inst = this.constructor as typeof Component;\n    inst.type = value;\n  }\n}\n\n/**\n * confirms whether the given object is a Component Type or Component Instance\n */\nexport function isComponent<T extends typeof Component | Component>(\n  object: T\n): object is T {\n  if (object[ComponentSymbol]) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * confirms whether the given component is of the stated component type\n */\nexport function isComponentOfType<T extends typeof Component | Component>(\n  object: Component | typeof Component,\n  type: T\n): object is T {\n  if (object.type === type.type) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// type BaseType = {\n//   readonly name: string;\n//   readonly type: number;\n// };\n\n// type BaseComp = {\n//   owner: number;\n//   [ComponentSymbol]: true;\n// } & BaseType;\n\n// type ProtoComp<C> = C & BaseComp;\n// type ProtoCompBuilder<C> = (owner: number) => ProtoComp<C>;\n\n// function registerComponent<C>(\n//   name: string,\n//   defaultData: C,\n//   nextId: number\n// ): [baseType: BaseType, builder: ProtoCompBuilder<C>] {\n//   const _typeId = nextId++;\n//   const _name = name;\n\n//   function makeComponent(owner: number) {\n//     const inner: ProtoComp<C> = {\n//       ...defaultData,\n//       owner,\n//       name: _name,\n//       type: _typeId,\n//       [ComponentSymbol]: true as const,\n//     };\n//     return inner;\n//   }\n\n//   return [\n//     {\n//       type: _typeId,\n//       name: _name,\n//     },\n//     makeComponent,\n//   ];\n// }\n", "import { Bag } from './Bag';\nimport { EcsInstance } from './EcsInstance';\nimport { Entity } from './Entity';\nimport { Component } from './Component';\n\nexport class ComponentManager {\n  private _ecsInstance: EcsInstance;\n  private _components: Bag<Bag<Component>>;\n  private _nextTypeId: number;\n  private _componentTypes: Record<PropertyKey, typeof Component> = {};\n\n  constructor(ecsInstance: EcsInstance) {\n    this._ecsInstance = ecsInstance;\n    this._components = new Bag<Bag<Component>>();\n    this._nextTypeId = 0;\n  }\n\n  get allTypes(): Record<PropertyKey, typeof Component> {\n    return this._componentTypes;\n  }\n\n  /**\n   * registers the given component class\n   * @param component the component class to register\n   */\n  registerComponent<C extends typeof Component>(component: C): void {\n    if (component.type < 0) {\n      component.type = this._nextTypeId++;\n      this._componentTypes[component.name] = component;\n    } else if (!this._componentTypes[component.name]) {\n      this._componentTypes[component.name] = component;\n    }\n    if (!this._components.has(component.type)) {\n      this._components.set(component.type, new Bag<Component>());\n    }\n  }\n\n  /**\n   * the current bag of component bags\n   */\n  get components(): Bag<Bag<Component>> {\n    return this._components;\n  }\n\n  /**\n   * WARNING this is a debug only function\n   * gets all the components of a given entity\n   * @param entity entity for which to retrieve components\n   * @returns a record with component entries by type name\n   */\n  getAllEntityComponents(entity: Entity): Record<string, Component> {\n    const allComponents: Record<string, Component> = {};\n    this._components.forEach(components => {\n      if (!components) return;\n      const component = components.get(entity.id);\n      if (!component) return;\n      allComponents[component.constructor.name] = component;\n    });\n    return allComponents;\n  }\n\n  /**\n   * WARNING this is a debug only function\n   * gets all the components of a given entity\n   * @param id id of entity for which to retrieve components\n   * @returns a record with component entries by type name\n   */\n  getAllEntityComponentsById(id: number): Option<Record<string, Component>> {\n    const entity = this._ecsInstance.getEntity(id);\n    if (!entity) return undefined;\n    return this.getAllEntityComponents(entity);\n  }\n\n  /**\n   * WARNING this is a debug function\n   * returns a component type by its type name\n   * @param name the class name string of the component type desired\n   * @returns that component type\n   */\n  getComponentTypeByTypeName(name: string): typeof Component {\n    return this._componentTypes[name];\n  }\n\n  /**\n   * gets all components of the given type\n   * @param component component type to retrieve\n   * @returns a bag of components of the type specified\n   */\n  getComponentsByType<C extends typeof Component>(\n    component: C\n  ): Option<Bag<InstanceType<C>>> {\n    return this._components.get(component.type);\n  }\n\n  /**\n   * get the component for the specified entity of the specified component class\n   * @param entity the owning eneity\n   * @param component the class of component to retrieve\n   * @returns the component for the entity or `undefined` if it doesnt exist\n   */\n  getComponent<C extends typeof Component>(\n    entity: Entity,\n    component: C\n  ): Option<InstanceType<C>> {\n    return this._components.get(component.type)?.get(entity.id);\n  }\n\n  /**\n   * get the component for the specified entity id of the specified component class\n   * @param id the id of the owning entity\n   * @param component the class of component to retrieve\n   * @returns the component for the entity or `undefined` if it doesnt exist\n   */\n  getComponentById<C extends typeof Component>(\n    id: number,\n    component: C\n  ): Option<InstanceType<C>> {\n    return this._components.get(component.type)?.get(id);\n  }\n\n  getComponentByType<C extends typeof Component>(\n    entity: Entity,\n    type: number\n  ): Option<InstanceType<C>> {\n    const components = this._components.get(type);\n    return components ? components.get(entity.id) : undefined;\n  }\n\n  getComponentByTypeAndId<C extends typeof Component>(\n    id: number,\n    type: number\n  ): Option<InstanceType<C>> {\n    const components = this._components.get(type);\n    return components ? components.get(id) : undefined;\n  }\n\n  /**\n   * adds the given component to the entity\n   * @param entity the entity to add the component to\n   * @param component the component instance to add to the entity\n   */\n  addComponent<C extends Component>(entity: Entity, component: C): void {\n    component.owner = entity.id;\n    const components = this._components.get(component.type);\n    if (components) {\n      components.set(entity.id, component);\n    }\n  }\n\n  /**\n   * adds the given component to the entity with the given id\n   * @param id the id of the entity to which to add the component\n   * @param component the component instance to add to the entity\n   */\n  addComponentById<C extends Component>(id: number, component: C): void {\n    component.owner = id;\n    const components = this._components.get(component.type);\n    if (components) {\n      components.set(id, component);\n    }\n  }\n\n  addComponents<C extends Component>(id: number, components: C[]): void {\n    for (let i = components.length; i--; ) {\n      this.addComponentById(id, components[i]);\n    }\n  }\n\n  /**\n   * remove all components for the given entity\n   * @param entity the entity from which to remove components\n   */\n  removeAllComponents(entity: Entity): void {\n    for (let i = 0; i < this._components.length; i++) {\n      const components = this._components.get(i);\n      if (components) {\n        components.set(entity.id, undefined);\n      }\n    }\n  }\n\n  /**\n   * remove the specific component instance from its owner\n   * @param component the component instance to remove\n   */\n  removeComponent<C extends Component>(component: C): void {\n    const components = this._components.get(component.type);\n    if (components) {\n      components.set(component.owner, undefined);\n    }\n  }\n\n  removeComponents<C extends Component>(components: C[]): void {\n    for (const component of components) {\n      this._components.get(component.type)?.set(component.owner, undefined);\n      // const bag = this._components.get(component.type);\n      // if (bag) {\n      //   bag.set(component.owner, undefined);\n      // }\n    }\n  }\n\n  /**\n   * remove the specific component instance from its owner\n   * @param component the component instance to remove\n   */\n  removeComponentType<C extends typeof Component>(\n    entity: Entity,\n    component: C\n  ): void {\n    const components = this._components.get(component.type);\n    if (components) {\n      components.set(entity.id, undefined);\n    }\n  }\n\n  removeComponentTypeById<C extends typeof Component>(\n    id: number,\n    component: C\n  ): void {\n    const components = this._components.get(component.type);\n    if (components) {\n      components.set(id, undefined);\n    }\n  }\n\n  /**\n   * handles the deletion of entities\n   * @param entity the deleted entity\n   */\n  deleteEntity(entity: Entity): void {\n    this.removeAllComponents(entity);\n  }\n\n  /**\n   * does the given entity have a component of the specified type\n   * @param entity the entity to check\n   * @param type the component type to check\n   * @returns `true` if the entity has that component, otherwise `false`\n   */\n  hasComponent(entity: Entity, type: number): boolean {\n    if (type < this._components.capacity) {\n      return this._components.get(type)?.has(entity.id) ?? false;\n    }\n    return false;\n  }\n\n  /**\n   * checks if the entity with he given id has a component of the specified entity type\n   * @param id the id of the entity to check\n   * @param type the type field of the component to check\n   * @returns `true` if the entity has the component otherwise `false`\n   */\n  hasComponentById(id: number, type: number): boolean {\n    if (type < this._components.capacity) {\n      return this._components.get(type)?.has(id) ?? false;\n    }\n    return false;\n  }\n\n  /**\n   * checks if the tagged entity has a component of the specified entity type\n   * @param tag the tagged entity to check\n   * @param type the type field of the component to check\n   * @returns `true` if the entity has the component otherwise `false`\n   */\n  hasComponentByTag(tag: string, type: number): boolean {\n    const entity = this._ecsInstance.getEntityByTag(tag);\n    if (!entity) return false;\n    return !!this._components.get(type)?.get(entity.id) ?? false;\n  }\n\n  /**\n   * checks if the tagged entity has a component of the specified entity type\n   * @param tag the tagged entity to check\n   * @param component the componen type to check\n   * @returns `true` if the entity has the component otherwise `false`\n   */\n  hasComponentOfTypeByTag(tag: string, component: typeof Component): boolean {\n    const entity = this._ecsInstance.tagManager.getEntityByTag(tag);\n    if (!entity) return false;\n    return !!this._components.get(component.type)?.get(entity.id) ?? false;\n  }\n\n  reset(): void {\n    for (let i = 0; i < this._components.length; i++) {\n      const components = this._components.get(i);\n      if (components) {\n        components.clear();\n      }\n    }\n  }\n\n  /**\n   * clean up all the managed components\n   */\n  cleanUp(): void {\n    for (let i = 0; i < this._components.length; i++) {\n      const components = this._components.get(i);\n      if (components) {\n        components.clear();\n      }\n    }\n    this._components.clear();\n    // reset the types\n    // Object.values(this._componentTypes).forEach((component) => {\n    //   component.type = -1;\n    // });\n    this._componentTypes = {};\n    this._nextTypeId = 0;\n  }\n}\n", "import { Entity } from './Entity';\nimport { Component } from './Component';\nimport { EcsInstance } from './EcsInstance';\n\nexport class ComponentMapper<T extends Component> {\n  private _type: number;\n  private _ecsInstance: EcsInstance;\n\n  constructor(component: new () => T, ecsInstance: EcsInstance) {\n    this._type = new component().type;\n    this._ecsInstance = ecsInstance;\n  }\n\n  /**\n   * get the component from the specified entity\n   * @param entity the entity to get the component for\n   * @returns the component if found, otherwise `undefined`\n   */\n  get(entity: Entity): T {\n    return this._ecsInstance.componentManager.getComponentByType(\n      entity,\n      this._type\n    ) as T;\n    // const components = this._ecsInstance.componentManager.components.get(\n    //   this._type\n    // );\n    // if (components) {\n    //   return components.get(entity.id) as T;\n    // } else {\n    //   return undefined;\n    // }\n  }\n\n  getById(id: number): T {\n    return this._ecsInstance.componentManager.getComponentByTypeAndId(\n      id,\n      this._type\n    ) as T;\n    // const components = this._ecsInstance.componentManager.components.get(\n    //   this._type\n    // );\n    // if (components) {\n    //   return components.get(id) as T;\n    // } else {\n    //   return undefined;\n    // }\n  }\n\n  /**\n   * get the component from the specified entity\n   * @param component class of component to retrieve\n   * @param entity the entity to get the component for\n   * @param ecsInstance the instance from which to retrieve the component\n   * @returns the component if found, otherwise `undefined`\n   */\n  static get<T extends typeof Component>(\n    component: T,\n    entity: Entity,\n    ecsInstance: EcsInstance\n  ): InstanceType<T> | undefined {\n    const components = ecsInstance.componentManager.components.get(\n      component.type\n    );\n    if (components) {\n      return components.get(entity.id) as InstanceType<T>;\n    } else {\n      return undefined;\n    }\n  }\n}\n", "export class Entity {\n  id = -1;\n}\n", "import { Bag } from './Bag';\nimport { Entity } from './Entity';\n\nexport class EntityManager {\n  private _entities: Bag<Entity>;\n  private _oldIds: number[];\n  private _nextId: number;\n\n  constructor() {\n    this._entities = new Bag<Entity>();\n    this._oldIds = [];\n    this._nextId = 0;\n  }\n\n  get entities(): Bag<Entity> {\n    return this._entities;\n  }\n\n  get oldIds(): Array<number> {\n    return this._oldIds;\n  }\n\n  /**\n   * create a new unique entity\n   * @returns the new entity\n   */\n  create(): Entity {\n    const entity = new Entity();\n    //re-use old IDs first\n    if (this._oldIds.length > 0) {\n      entity.id = this._oldIds.shift() as number;\n    } else {\n      entity.id = this._nextId++;\n    }\n    //add to entities, and return a reference\n    this._entities.set(entity.id, entity);\n    return entity;\n  }\n\n  /**\n   * returns the entity with the spcified `id` if it exists\n   * @param id the id of the entity requested\n   * @returns the requried entity if found or `undefined`\n   */\n  getEntity(id: number): Option<Entity> {\n    return this._entities.get(id);\n  }\n\n  /**\n   * delete an entity\n   * @param entity the entity to delete\n   */\n  deleteEntity(entity: Entity): void {\n    if (!this._entities.get(entity.id)) return; // prevent double deletion of entities\n    this._oldIds.push(entity.id);\n    this._entities.set(entity.id, undefined);\n  }\n\n  reset(): void {\n    this._oldIds = [];\n    this._entities.clear();\n    this._nextId = 0;\n  }\n\n  /**\n   * clean up the manager, clearing old ids and entities\n   */\n  cleanUp(): void {\n    this._oldIds = [];\n    this._entities.clear();\n    this._nextId = 0;\n  }\n}\n\nexport default EntityManager;\n", "import { EcsInstance } from './EcsInstance';\nimport { EntitySystem } from './EntitySystem';\nimport { Bag } from './Bag';\nimport { Entity } from './Entity';\nimport type {\n  ComponentOptionTuple,\n  ComponentTuple,\n  SmartResolve,\n  SmartUpdate,\n} from 'types/tuples';\nimport { EntitySystemArgs, SystemRegistrationArgs } from 'types/system';\n\nexport class SystemManager {\n  private _ecsInstance: EcsInstance;\n  private _staticSystems: EntitySystem<any, any, any, any>[];\n  private _reactiveSystems: EntitySystem<any, any, any, any>[];\n  private _systemTypes: Record<string, EntitySystem<any, any, any, any>> = {};\n  private _systems!: EntitySystem<any, any, any, any>[];\n  private _nextId: number;\n\n  constructor(ecsInstance: EcsInstance) {\n    this._ecsInstance = ecsInstance;\n    this._staticSystems = [];\n    this._reactiveSystems = [];\n    this._nextId = 0;\n  }\n\n  /**\n   * an array of the currently managed systems\n   * memoized on startup\n   */\n  get systems(): EntitySystem<any, any, any, any>[] {\n    if (this._systems) return this._systems;\n    this._systems = this._staticSystems.concat(this._reactiveSystems);\n    return this._systems;\n  }\n\n  /**\n   * WARNING this is a debug function\n   * get the system registered by the specified class name\n   * @param name class name of the registered system\n   * @returns the registered system with the given name\n   */\n  getSystemByTypeName<T extends EntitySystem<any, any, any, any>>(\n    name: string\n  ): T {\n    return this._systemTypes[name] as T;\n  }\n\n  /**\n   * register a given system class\n   * @param System the system class to register\n   * @param args the system registration arguments\n   * @returns a reference to the registered system\n   */\n  registerSystem<\n    T extends ComponentTuple,\n    V extends ComponentOptionTuple,\n    W extends ComponentTuple,\n    Props,\n    Sys extends typeof EntitySystem<T, Props, V, W>,\n    Args extends EntitySystemArgs<T, Props, V, W>\n  >(\n    System: Sys,\n    args: SystemRegistrationArgs<Props>\n  ): EntitySystem<T, Props, V, W> {\n    const props = {\n      id: this._nextId++,\n      ecsInstance: this._ecsInstance,\n      reactive: false,\n      priority: 0,\n      ...args,\n    } as Args;\n    const system = new System(props);\n\n    system.buildQuery();\n\n    system.componentTypes.forEach(component => {\n      this._ecsInstance.componentManager.registerComponent(component);\n    });\n    if (system.isReactive) {\n      this._reactiveSystems.push(system);\n    } else {\n      this._staticSystems.push(system);\n    }\n    this._systemTypes[system.constructor.name] = system;\n    return system;\n  }\n\n  /**\n   * initialize all registered systems\n   */\n  initializeSystems(): void {\n    const systems = this.systems;\n    for (let i = systems.length; i--; ) {\n      this.systems[i].initialize?.();\n    }\n  }\n\n  /**\n   * load all registered systems\n   */\n  loadSystems(): void {\n    const systems = this.systems;\n    for (let i = systems.length; i--; ) {\n      const system = this.systems[i];\n      system.load?.(system.entities);\n    }\n  }\n\n  initialResolve(entity: Entity): void {\n    const systems = this.systems;\n    for (let i = systems.length; i--; ) {\n      const system = this.systems[i];\n      if (system.query.validate(entity)) {\n        system.initialResolve(entity);\n      }\n    }\n  }\n\n  initialCreate(entity: Entity): void {\n    const systems = this.systems;\n    for (let i = systems.length; i--; ) {\n      const system = this.systems[i];\n      system.query.validate(entity) && system.initialCreate(entity);\n    }\n  }\n\n  /**\n   * attempt to add the created entity to all registered systems\n   * @param entity the entity to add\n   */\n  createEntity(entity: Entity): void {\n    // since this is performance critical, we do each system explicitly\n    // rather than using `this.systems`\n    for (let i = this._staticSystems.length; i--; ) {\n      const system = this._staticSystems[i];\n      system.query.validate(entity) && system.createEntity(entity);\n    }\n    for (let i = this._reactiveSystems.length; i--; ) {\n      const system = this._reactiveSystems[i];\n      system.query.validate(entity) && system.createEntity(entity);\n    }\n  }\n\n  /**\n   * resolve the given entity with the static systems.  if valid, will be added\n   * if it doesnt already have the entity or removed if invalid\n   * @param resolving the entities to resolve\n   */\n  resolveEntities(resolving: Bag<SmartResolve>): void {\n    for (let i = resolving.length; i--; ) {\n      const data = resolving.get(i);\n      if (!data) continue;\n      const [entity, ignored] = data;\n      for (let i = this._staticSystems.length; i--; ) {\n        const system = this._staticSystems[i];\n        if (ignored[system.id]) continue;\n        if (system.query.validate(entity)) {\n          system.addEntity(entity);\n        } else {\n          // attempt to remove if we ever had it before\n          system.removeEntity(entity);\n        }\n      }\n\n      for (let i = this._reactiveSystems.length; i--; ) {\n        const system = this._reactiveSystems[i];\n        if (ignored[system.id]) continue;\n        if (system.query.validate(entity)) {\n          system.addEntity(entity);\n        }\n      }\n    }\n  }\n\n  // IDEA: for when we introduce smart resolves\n  // resolveAdd(components: Component[]) {\n  //   const systems = this.systems;\n  //   // for-of is a little faster with sparse data\n  //   for (const system of systems) {\n  //     let valid = false;\n  //     for (const component of components) {\n  //       // IF any of the components added are valid,\n  //       valid = valid || system.query.isValidComponent(component);\n  //     }\n  //     // AND we're not an invalid entity\n  //     if (valid && system.query.isValidById(components[0].owner)) {\n  //       // THEN add this entity\n  //       system.addEntityById(components[0].owner);\n  //     }\n  //   }\n  // }\n\n  // IDEA: for when we introduce smart resolves\n  // resolveRemove(components: Component[]) {\n  //   const systems = this.systems;\n  //   // for-of is a little faster with sparse data\n  //   for (const system of systems) {\n  //     let needed = false;\n  //     for (const component of components) {\n  //       // IF any are a needed component\n  //       needed = needed || system.query.isNeededComponent(component);\n  //     }\n\n  //     // AND we're still considered valid\n  //     if (needed && system.query.isValidById(components[0].owner)) {\n  //       // THEN remove this entity\n  //       system.removeEntityById(components[0].owner);\n  //     }\n  //   }\n  // }\n\n  /**\n   * delete the given entity from all registered systems\n   * @param entity the deleted entity\n   */\n  deleteEntity(entity: Entity): void {\n    for (let i = this._staticSystems.length; i--; ) {\n      this._staticSystems[i].deleteEntity(entity);\n    }\n    // due to the way that we keep reactive systems sparse, we\n    // must validate beforehand. this allows reactive systems\n    // to receive deletion notifications and do any special\n    // cleanup if they alter their internal state based on prior\n    // processed entities\n    for (let i = this._reactiveSystems.length; i--; ) {\n      const system = this._reactiveSystems[i];\n      system.query.validate(entity) && system.deleteEntity(entity);\n    }\n  }\n\n  /**\n   * IDEA: make update work like smart resolves (should be faster)\n   * notify the registered reactive systems that any entities with the\n   * supplied components should be added for processing\n   * @param updated the arrays of components by owner requiring updates\n   */\n  update(updated: Bag<Bag<SmartUpdate>>): void {\n    for (let i = this._systems.length; i--; ) {\n      const system = this._systems[i];\n      for (let owner = updated.length; owner--; ) {\n        const data = updated.get(owner);\n        if (!data) continue;\n        // IF any of the components added are valid,\n        const maybeValid = data.some(item => {\n          if (item) {\n            const [component, ignored] = item;\n            return (\n              !ignored[system.id] && system.query.isValidComponent(component)\n            );\n          }\n          return false;\n        });\n        // AND we're not an invalid entity\n        if (maybeValid && system.query.isValidById(owner)) {\n          // THEN add this entity\n          if (system.isReactive) system.addByUpdateById(owner);\n          else {\n            // static system\n            system.updateById(owner, data);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * notify the registered reactive systems that these entities\n   * should be added for processing\n   * @param entity the entity to update\n   */\n  updateEntity(entity: Entity): void {\n    for (let i = this._systems.length; i--; ) {\n      const system = this._systems[i];\n      if (system.query.validate(entity)) {\n        system.isReactive && system.addByUpdate(entity);\n        !system.isReactive && system.update(entity);\n      }\n    }\n  }\n\n  reset(): void {\n    const systems = this.systems;\n    for (let i = systems.length; i--; ) {\n      this.systems[i].resetSystem();\n    }\n  }\n\n  /**\n   * clean up all registred systems\n   */\n  cleanUp(): void {\n    this.systems.forEach(system => system.cleanSystem());\n    this._staticSystems = [];\n    this._reactiveSystems = [];\n    this._systemTypes = {};\n    this._systems = [];\n  }\n}\n", "import { Entity } from './Entity';\n\nexport class TagManager {\n  private _tags: Record<string, Entity> = {};\n\n  /**\n   * gets the entity assigned to the given tag\n   * @param tag the tag to retrieve\n   * @returns the entity if tagged, otherwise `undefined`\n   */\n  getEntityByTag(tag: string): Entity | undefined {\n    return this._tags[tag];\n  }\n\n  /**\n   * tags an entity\n   * @param tag the tag to use\n   * @param entity the entity to tag\n   */\n  tagEntity(tag: string, entity: Entity): void {\n    this._tags[tag] = entity;\n  }\n\n  tagExists(tag: string): boolean {\n    return Object.hasOwn(this._tags, tag);\n  }\n\n  /**\n   * delete the given entity from all tags\n   * @param entity the entity to delete\n   */\n  deleteEntity(entity: Entity): void {\n    Object.keys(this._tags).forEach((key) => {\n      if (this._tags[key].id === entity.id) delete this._tags[key];\n    });\n  }\n\n  /**\n   * remove the given tag\n   * @param tag the tag to remove\n   */\n  removeTag(tag: string): void {\n    delete this._tags[tag];\n  }\n\n  /**\n   * clean up all tags\n   */\n  cleanUp(): void {\n    this._tags = {};\n  }\n}\n", "import { Bag } from './Bag';\nimport { Entity } from './Entity';\n\nexport class GroupManager {\n  private _groups: Record<PropertyKey, Bag<Entity>>;\n\n  constructor() {\n    this._groups = {};\n  }\n\n  get groups(): Record<PropertyKey, Bag<Entity>> {\n    return this._groups;\n  }\n\n  /**\n   * adds a given entity to the specified group\n   * @param group the group to which to add the entity\n   * @param entity the entity to add\n   */\n  addEntityToGroup(group: string, entity: Entity): void {\n    if (!this._groups[group]) {\n      this._groups[group] = new Bag();\n    }\n\n    if (!this._groups[group].includes(entity)) {\n      this._groups[group].add(entity);\n    }\n  }\n\n  /**\n   * returns the `Bag` of entities for the specified group\n   * @param group the group to retrieve\n   * @returns the bag for the specified group\n   */\n  getGroup(group: string): Bag<Entity> | undefined {\n    return this._groups[group];\n  }\n\n  /**\n   * delete the specified entity from all groups\n   * @param entity the entity to delete\n   */\n  deleteEntity(entity: Entity): void {\n    Object.values(this._groups).forEach((group: Bag<Entity>) => {\n      group.remove(entity);\n    });\n  }\n\n  removeEntityFromGroup(entity: Entity, group: string): void {\n    const targetGroup = this._groups[group];\n    if (!targetGroup) return;\n    targetGroup.remove(entity);\n  }\n\n  /**\n   * remove a specified group\n   * @param group the group to remove\n   */\n  removeGroup(group: string): void {\n    delete this._groups[group];\n  }\n\n  /**\n   * clean up all the groups\n   */\n  cleanUp(): void {\n    Object.keys(this._groups).forEach((key) => {\n      this._groups[key].clear();\n      delete this._groups[key];\n    });\n  }\n}\n", "import { EntitySystem } from './EntitySystem';\n\nexport class Scheduler {\n  private _systems: EntitySystem<any, any, any, any>[] = [];\n\n  /**\n   * currently scheduled systems\n   */\n  get systems(): EntitySystem<any, any, any, any>[] {\n    return this._systems;\n  }\n\n  /**\n   * set the scheduled systems\n   */\n  set systems(value: EntitySystem<any, any, any, any>[]) {\n    this._systems = value;\n  }\n\n  /**\n   * clean up systems\n   */\n  cleanUp(): void {\n    this._systems = [];\n  }\n\n  /**\n   * sort the systems by priority\n   */\n  sortSystems(): void {\n    this._systems.sort(\n      (\n        a: EntitySystem<any, any, any, any>,\n        b: EntitySystem<any, any, any, any>\n      ) => b.priority - a.priority\n    );\n  }\n\n  /**\n   * run the systems in order of priority\n   */\n  runSystems(): void {\n    const systems = this._systems;\n    for (let i = systems.length; i--; ) {\n      const system = systems[i];\n      if (system.active) {\n        system.processAll();\n        if (system.isReactive) system.entities.clear();\n      }\n    }\n  }\n}\n", "import type {\n  OptionTuple,\n  OrderedNoneTuple,\n  OrderedOptionTuple,\n  OrderedSomeTuple,\n} from 'types/tuples';\n\nexport function is_some<T>(val: Option<T>): val is Some<T> {\n  if (!!val || typeof val === 'number' || typeof val === 'boolean') return true;\n  return false;\n}\n\nexport function is_none<T>(val: Option<T>): val is None {\n  if (is_some(val)) return false;\n  return true;\n}\n\nexport function is_ok<T, E extends Error>(val: Result<T, E>): val is Ok<T> {\n  if (val instanceof Error) return false;\n  return true;\n}\n\nexport function is_err<T, E extends Error>(val: Result<T, E>): val is Err<E> {\n  if (val instanceof Error) return true;\n  return false;\n}\n\nexport function all_some<T extends OptionTuple<T>>(\n  val: OrderedOptionTuple<T>\n): val is OrderedSomeTuple<T> {\n  if (val.some(v => is_none(v))) return false;\n  return true;\n}\n\nexport function all_none<T extends OptionTuple<T>>(\n  val: OrderedOptionTuple<T>\n): val is OrderedNoneTuple<T> {\n  if (val.some(v => is_some(v))) return false;\n  return true;\n}\n\nexport function lerp(a: number, b: number, percent: number): number {\n  return (b - a) * percent + a;\n}\n\nexport function makeTimer(deltaMax: number) {\n  let start = performance.now();\n  let stop = Number.MAX_SAFE_INTEGER;\n  let delta = 0;\n\n  function begin(): void {\n    start = performance.now();\n  }\n\n  function end(text: string, ...args: any[]): void {\n    stop = performance.now();\n\n    delta = stop - start;\n\n    if (delta > deltaMax) {\n      console.info(`ms: ${delta} -`, text, ...args);\n    }\n  }\n\n  return {\n    begin,\n    end,\n    get delta(): number {\n      return delta;\n    },\n  };\n}\n", "import { is_none, is_some } from './utils';\nimport { Bag } from './Bag';\nimport { Component } from './Component';\nimport { EcsInstance } from './EcsInstance';\nimport { Entity } from './Entity';\nimport type {\n  ComponentBuilderFunction,\n  ComponentMaybeBuilderFunction,\n  DataBuilderFunction,\n  EntityBuilder,\n  StringBuilderFunction,\n} from 'types/builder';\n\n/**\n * creates a builder that allows you to chain calls to build up an entity\n * making creation of entities extremely easy while remaining lightweight\n * and performant.\n */\nexport function makeEntityBuilder(ecs: EcsInstance): EntityBuilder {\n  let entity!: Entity;\n  const alsoCallbacks: DataBuilderFunction[] = [];\n  const components = new Bag<Component>();\n  const componentCallbacks: (\n    | ComponentBuilderFunction\n    | ComponentMaybeBuilderFunction\n  )[] = [];\n  const groupCallbacks: StringBuilderFunction[] = [];\n  const groups: string[] = [];\n  let initCallback: Option<DataBuilderFunction> = null;\n  const tags: string[] = [];\n  const tagCallbacks: StringBuilderFunction[] = [];\n  const workingData: Record<PropertyKey, unknown> = {};\n  const builder: EntityBuilder = {\n    build<E extends Error = Error>(): Result<Entity, E> {\n      entity = ecs.createEntity();\n      let currentBuilder: EntityBuilder = this;\n      try {\n        currentBuilder = is_some(initCallback)\n          ? initCallback(currentBuilder)\n          : this;\n        for (let i = 0; i < componentCallbacks.length; i++) {\n          const component = componentCallbacks[i](currentBuilder);\n          if (is_some(component)) {\n            components.set(component.type, component);\n            ecs.addComponent(entity, component);\n          }\n        }\n        // we do standard adds after callbacks because callbacks can add inside them\n        for (let i = 0; i < components.length; i++) {\n          const component = components.get(i);\n          component && ecs.addComponent(entity, component);\n        }\n        for (let i = 0; i < alsoCallbacks.length; i++) {\n          currentBuilder = alsoCallbacks[i](currentBuilder);\n        }\n        for (let i = 0; i < tags.length; i++) {\n          ecs.tagManager.tagEntity(tags[i], entity);\n        }\n        for (let i = 0; i < tagCallbacks.length; i++) {\n          ecs.tagManager.tagEntity(tagCallbacks[i](currentBuilder), entity);\n        }\n        for (let i = 0; i < groups.length; i++) {\n          ecs.groupManager.addEntityToGroup(groups[i], entity);\n        }\n        for (let i = 0; i < groupCallbacks.length; i++) {\n          ecs.groupManager.addEntityToGroup(\n            groupCallbacks[i](currentBuilder),\n            entity\n          );\n        }\n        return entity;\n      } catch (e) {\n        console.error('ENTITY BUILDER ERROR:', e);\n        ecs.abort(entity);\n        return e as E;\n      }\n    },\n    add(component: Component): EntityBuilder {\n      components.set(component.type, component);\n      return this;\n    },\n    addMaybe(maybe: Option<Component>): EntityBuilder {\n      if (is_some(maybe)) {\n        components.set(maybe.type, maybe);\n      }\n      return this;\n    },\n    addMaybeWith(callback: ComponentMaybeBuilderFunction): EntityBuilder {\n      componentCallbacks.push(callback);\n      return this;\n    },\n    addWith(callback: ComponentBuilderFunction): EntityBuilder {\n      componentCallbacks.push(callback);\n      return this;\n    },\n    also(callback: DataBuilderFunction): EntityBuilder {\n      alsoCallbacks.push(callback);\n      return this;\n    },\n    get<C extends typeof Component>(component: C): InstanceType<C> {\n      const comp = components.get(component.type);\n      if (is_none(comp))\n        throw new Error(`builder component ${component.name} is undefined`);\n      return comp as InstanceType<C>;\n    },\n    getData<T>(key: PropertyKey): T {\n      const data = workingData[key];\n      if (is_none(data))\n        throw new Error(`builder data ${key as string} is undefined`);\n      return data as T;\n    },\n    getEntity(): Entity {\n      return entity;\n    },\n    group(group: string): EntityBuilder {\n      groups.push(group);\n      return this;\n    },\n    groupWith(callback: StringBuilderFunction): EntityBuilder {\n      groupCallbacks.push(callback);\n      return this;\n    },\n    init(callback: DataBuilderFunction): EntityBuilder {\n      initCallback = callback;\n      return this;\n    },\n    insertData<T>(key: PropertyKey, value: T): EntityBuilder {\n      workingData[key] = value;\n      return this;\n    },\n    setData<T>(key: PropertyKey, value: T): void {\n      workingData[key] = value;\n    },\n    tag(tag: string): EntityBuilder {\n      tags.push(tag);\n      return this;\n    },\n    tagWith(callback: StringBuilderFunction): EntityBuilder {\n      tagCallbacks.push(callback);\n      return this;\n    },\n  };\n  return builder;\n}\n", "import type { EcsInstance } from './EcsInstance';\nimport type { ComponentTuple, OrderedComponentTuple } from 'types/tuples';\n\n// export declare type VariadricQuery<T extends ComponentTuple> = [...T];\n\nexport class FuncQuery<T extends ComponentTuple> {\n  ecs!: EcsInstance;\n  data!: [...T];\n\n  constructor(ecs: EcsInstance, data: [...T]) {\n    this.ecs = ecs;\n    this.data = data;\n  }\n\n  join(): IterableIterator<OrderedComponentTuple<T>> {\n    return this.ecs.query<T>(this.data);\n  }\n}\n", "import { EntityManager } from './EntityManager';\nimport { ComponentManager } from './ComponentManager';\nimport { SystemManager } from './SystemManager';\nimport { TagManager } from './TagManager';\nimport { GroupManager } from './GroupManager';\nimport { ComponentMapper } from './ComponentMapper';\nimport { Scheduler } from './Scheduler';\nimport { EntitySystem } from './EntitySystem';\nimport { Bag } from './Bag';\nimport { makeEntityBuilder } from './EntityBuilder';\nimport { FuncQuery } from './FuncQuery';\nimport { is_none, makeTimer } from './utils';\nimport { Entity } from './Entity';\nimport { Component } from './Component';\nimport type {\n  ComponentOptionTuple,\n  ComponentTuple,\n  JoinedData,\n  JoinedResult,\n  OrderedComponentOptionTuple,\n  OrderedComponentTuple,\n  SmartResolve,\n  SmartUpdate,\n} from 'types/tuples';\nimport type { EntityBuilder } from 'types/builder';\nimport type { QueryFunc } from 'types/query';\nimport type { SystemRegistrationArgs } from 'types/system';\n\nconst timer = makeTimer(1);\n\nexport class EcsInstance {\n  entityManager: EntityManager;\n  componentManager: ComponentManager;\n  systemManager: SystemManager;\n  tagManager: TagManager;\n  groupManager: GroupManager;\n  scheduler: Scheduler;\n\n  private _creating: Bag<Entity>;\n  private _resolving: Bag<SmartResolve>;\n  private _deleting: Bag<Entity>;\n  private _updatingEntities: Entity[];\n  private _updating: Bag<Bag<SmartUpdate>>;\n  private _delta: number;\n  private _lastTime: number;\n  private _elapsed: number;\n  private _destroyed = false;\n\n  constructor() {\n    this.entityManager = new EntityManager();\n    this.componentManager = new ComponentManager(this);\n    this.systemManager = new SystemManager(this);\n    this.tagManager = new TagManager();\n    this.groupManager = new GroupManager();\n    this.scheduler = new Scheduler();\n    this._creating = new Bag<Entity>();\n    this._resolving = new Bag<SmartResolve>();\n    this._deleting = new Bag<Entity>();\n    this._updatingEntities = [];\n    this._updating = new Bag<Bag<SmartUpdate>>();\n    this._delta = 0;\n    this._lastTime = 0;\n    this._elapsed = 0;\n  }\n\n  get delta(): number {\n    return this._delta;\n  }\n\n  get elapsed(): number {\n    return this._elapsed;\n  }\n\n  get lastTime(): number {\n    return this._lastTime;\n  }\n\n  /**\n   * stop a recently created entity from being resolved\n   * @param entity the entity to abort\n   */\n  abort(entity: Entity): void {\n    this._creating.set(entity.id, undefined);\n    this.componentManager.deleteEntity(entity);\n    this.entityManager.deleteEntity(entity);\n  }\n\n  /**\n   * add a component to an entity\n   * @param entity the entity to receive the component\n   * @param component the component to add\n   */\n  addComponent(entity: Entity, component: Component): void {\n    this.componentManager.addComponent(entity, component);\n  }\n\n  addComponentById(id: number, component: Component): void {\n    this.componentManager.addComponentById(id, component);\n  }\n\n  /**\n   * create a new entity\n   * @returns the created entity\n   */\n  createEntity(): Entity {\n    const entity = this.entityManager.create();\n    this._creating.set(entity.id, entity);\n    return entity;\n  }\n\n  create(): EntityBuilder {\n    return makeEntityBuilder(this);\n  }\n\n  /**\n   * delete an entity\n   * @param entity the entity to delete\n   */\n  deleteEntity(entity: Entity): void {\n    this._deleting.set(entity.id, entity);\n  }\n\n  /**\n   * deletes multiple entities\n   * @param entities the entity to delete\n   */\n  deleteEntities(entities: Entity[]): void {\n    for (let i = entities.length; i--; ) {\n      this.deleteEntity(entities[i]);\n    }\n  }\n\n  deleteEntityBag(entities: Bag<Entity>): void {\n    this._deleting.setBag(entities);\n  }\n\n  getComponentsByType(component: typeof Component): Option<Bag<Component>> {\n    return this.componentManager.getComponentsByType(component);\n  }\n\n  /**\n   * get the component for the specified entity of the specified component class\n   * @param entity the owning entity\n   * @param component the class of component to retrieve\n   * @returns the component for the entity or `undefined` if it doesnt exist\n   */\n  getComponent<C extends typeof Component>(\n    entity: Entity,\n    component: C\n  ): Option<InstanceType<C>> {\n    return this.componentManager.getComponent(entity, component);\n  }\n\n  getComponentById(id: number, component: typeof Component): Option<Component> {\n    return this.componentManager.getComponentById(id, component);\n  }\n\n  getComponentByTag<T extends typeof Component>(\n    tag: string,\n    component: T\n  ): Option<InstanceType<T>> {\n    const entity = this.getEntityByTag(tag);\n    if (!entity) return undefined;\n    return this.componentManager.getComponent(entity, component);\n  }\n\n  /**\n   * a very useful component retrieval function\n   * @param entity entity who owns the component\n   * @param component the component type to retrieve\n   * @returns the instance of that component, if any\n   */\n  getComponentOfType<T extends typeof Component>(\n    entity: Entity,\n    component: T\n  ): Option<InstanceType<T>> {\n    return this.getComponent(entity, component) as InstanceType<T>;\n  }\n\n  /**\n   * a very useful component retrieval function\n   * @param id id of entity who owns the component\n   * @param component the component type to retrieve\n   * @returns the instance of that component, if any\n   */\n  getComponentOfTypeById<T extends typeof Component>(\n    id: number,\n    component: T\n  ): Option<InstanceType<T>> {\n    return this.getComponentById(id, component) as InstanceType<T>;\n  }\n\n  getComponentOfTypeByTag<T extends typeof Component>(\n    tag: string,\n    component: T\n  ): Option<InstanceType<T>> {\n    return this.getComponentByTag(tag, component) as InstanceType<T>;\n  }\n\n  /**\n   * gets a component for the given entity with the given typeId\n   * @param entity to retrieve component from\n   * @param typeId the numeric type of the component\n   * @returns the instance of that component type, if any\n   */\n  getComponentByTypeId<T extends typeof Component>(\n    entity: Entity,\n    typeId: number\n  ): Option<InstanceType<T>> {\n    return this.componentManager.getComponentByType(\n      entity,\n      typeId\n    ) as InstanceType<T>;\n  }\n\n  /**\n   * returns the entity with the spcified `id` if it exists\n   * @param id the id of the entity requested\n   * @returns the required entity if found or `undefined`\n   */\n  getEntity(id: number): Option<Entity> {\n    return this.entityManager.getEntity(id);\n  }\n\n  /**\n   * gets the entity assigned to the given tag\n   * @param tag the tag to retrieve\n   * @returns the entity if tagged, otherwise `undefined`\n   */\n  getEntityByTag(tag: string): Option<Entity> {\n    return this.tagManager.getEntityByTag(tag);\n  }\n\n  tagExists(tag: string): boolean {\n    return this.tagManager.tagExists(tag);\n  }\n\n  /**\n   * returns the `Bag` of entities for the specified group\n   * @param group the group to retrieve\n   * @returns the bag for the specified group\n   */\n  getGroup(group: string): Option<Bag<Entity>> {\n    return this.groupManager.getGroup(group);\n  }\n\n  /**\n   * checks if the given entity has a component of the specified entity type\n   * @param entity the entity to check\n   * @param type the type field of the component to check\n   * @returns `true` if the entity has the component otherwise `false`\n   */\n  hasComponent(entity: Entity, type: number): boolean {\n    return this.componentManager.hasComponent(entity, type);\n  }\n\n  /**\n   * checks if the given entity has a component of the specified entity type\n   * @param entity the entity to check\n   * @param componentType type to check\n   * @returns `true` if the entity has the component otherwise `false`\n   */\n  hasComponentOfType<C extends typeof Component>(\n    entity: Entity,\n    componentType: C\n  ): boolean {\n    return this.componentManager.hasComponent(entity, componentType.type);\n  }\n\n  /**\n   * checkes if the given entity has a component of the specified entity type\n   * @param id the entity id to check\n   * @param componentType type to check\n   * @returns `true` if the entity has the component otherwise `false`\n   */\n  hasComponentOfTypeById<C extends typeof Component>(\n    id: number,\n    componentType: C\n  ): boolean {\n    return this.componentManager.hasComponentById(id, componentType.type);\n  }\n\n  /**\n   * checks if the entity witht he given id has a component of the specified entity type\n   * @param id the id of the entity to check\n   * @param type the type field of the component to check\n   * @returns `true` if the entity has the component otherwise `false`\n   */\n  hasComponentById(id: number, type: number): boolean {\n    return this.componentManager.hasComponentById(id, type);\n  }\n\n  /**\n   * checks if the tagged entity has a component of the specified entity type\n   * @param tag the tagged entity to check\n   * @param type the type field of the component to check\n   * @returns `true` if the entity has the component otherwise `false`\n   */\n  hasComponentByTag(tag: string, type: number): boolean {\n    return this.componentManager.hasComponentByTag(tag, type);\n  }\n  /**\n   * checks if the tagged entity has a component of the specified entity type\n   * @param tag the tagged entity to check\n   * @param component the componen type to check\n   * @returns `true` if the entity has the component otherwise `false`\n   */\n  hasComponentOfTypeByTag<C extends typeof Component>(\n    tag: string,\n    component: C\n  ): boolean {\n    return this.componentManager.hasComponentOfTypeByTag(tag, component);\n  }\n\n  initializeSystems(): void {\n    this.systemManager.initializeSystems();\n  }\n\n  loadSystems(): void {\n    this.systemManager.loadSystems();\n  }\n\n  /**\n   * makes a component mapper for the specific component type\n   * @param component a component type to use to build the mapper\n   * @return a component mapper for the given component type\n   */\n  makeMapper<C extends Component>(component: new () => C): ComponentMapper<C> {\n    return new ComponentMapper<C>(component, this);\n  }\n\n  /**\n   * registeres a component with the component manager\n   * @param component the component type to register\n   */\n  registerComponent<C extends typeof Component>(component: C): void {\n    this.componentManager.registerComponent(component);\n  }\n\n  registerSystem<\n    T extends ComponentTuple,\n    V extends ComponentOptionTuple,\n    W extends ComponentTuple,\n    Props,\n    Sys extends typeof EntitySystem<T, Props, V, W>\n  >(\n    System: Sys,\n    args: SystemRegistrationArgs<Props>\n  ): EntitySystem<T, Props, V, W> {\n    return this.systemManager.registerSystem(System, args);\n  }\n\n  /**\n   * remove the given component from its owner\n   * @param component the component to remove\n   */\n  removeComponent(component: Component): void {\n    this.componentManager.removeComponent(component);\n  }\n\n  /**\n   * remove the component of the given type from the specified entity\n   * @param entity the target entity\n   * @param component the component type to remove\n   */\n  removeComponentType(entity: Entity, component: typeof Component): void {\n    this.componentManager.removeComponentType(entity, component);\n  }\n\n  removeComponentTypeById(id: number, component: typeof Component): void {\n    this.componentManager.removeComponentTypeById(id, component);\n  }\n\n  /**\n   * resolve the given entity against the current ecs instance. This will\n   * let all registered systems whose queries match the entity receive it\n   * for processing\n   * @param entity the entity to resolve\n   */\n  resolve(entity: Entity, ignoredSystems: number[] = []): void {\n    const ignored: boolean[] = [];\n    for (let i = ignoredSystems.length; i--; ) {\n      ignored[ignoredSystems[i]] = true;\n    }\n    this._resolving.set(entity.id, [entity, ignored]);\n  }\n\n  /**\n   * resolve the entity that has the given id against he current ecs instance.\n   * this will let all registered sytems whose queries match the entity receive\n   * it for processing\n   * @param id the id of the entity to resolve\n   */\n  resolveById(id: number, ignoredSystems: number[] = []): void {\n    const ignored: boolean[] = [];\n    for (let i = ignoredSystems.length; i--; ) {\n      ignored[ignoredSystems[i]] = true;\n    }\n    const entity = this.getEntity(id);\n    entity && this._resolving.set(id, [entity, ignored]);\n  }\n\n  /**\n   * performs initial resolve of all early defined entities\n   */\n  initialResolve(): void {\n    const creating = this._creating;\n    this._creating = new Bag<Entity>(creating.capacity);\n    // verify there is work to do in the sparse bag\n    if (creating.count > 0) {\n      for (let i = creating.length; i--; ) {\n        const entity = creating.get(i);\n        entity && this.systemManager.initialResolve(entity);\n      }\n    }\n  }\n\n  /**\n   * performs initial create of all early defined entities (load phase)\n   */\n  initialCreate(): void {\n    const creating = this._creating;\n    this._creating = new Bag<Entity>(creating.capacity);\n    // verify there is work to do in the sparse bag\n    if (creating.count > 0) {\n      for (let i = creating.length; i--; ) {\n        const entity = creating.get(i);\n        entity && this.systemManager.initialCreate(entity);\n      }\n    }\n  }\n\n  /**\n   * triggers the resolution update cycle. this processes all new, resolving,\n   * updating, and deleting entities\n   */\n  resolveEntities(): void {\n    // move the memory into some temp variables, so that if any of the below\n    // processes cause an update to any of them, they are not possibly lost\n    const deleting = this._deleting,\n      resolving = this._resolving,\n      updating = this._updating,\n      updatingEntities = this._updatingEntities,\n      creating = this._creating;\n\n    this._deleting = new Bag<Entity>(deleting.capacity);\n    this._resolving = new Bag<SmartResolve>(resolving.capacity);\n    this._updating = new Bag<Bag<SmartUpdate>>(updating.capacity);\n    this._updatingEntities = [];\n\n    if (deleting.count > 0) {\n      for (let i = deleting.length; i--; ) {\n        const entity = deleting.get(i);\n        if (!entity) continue;\n        this.systemManager.deleteEntity(entity);\n        this.tagManager.deleteEntity(entity);\n        this.groupManager.deleteEntity(entity);\n        this.componentManager.deleteEntity(entity);\n        this.entityManager.deleteEntity(entity);\n      }\n    }\n\n    if (resolving.count > 0) {\n      this.systemManager.resolveEntities(resolving);\n    }\n\n    if (updating.count > 0) {\n      this.systemManager.update(updating);\n    }\n\n    for (let i = updatingEntities.length; i--; ) {\n      this.systemManager.updateEntity(updatingEntities[i]);\n    }\n\n    // verify there is work to do in the sparse bag\n    if (creating.count > 0) {\n      for (let i = creating.length; i--; ) {\n        const entity = creating.get(i);\n        entity && this.systemManager.createEntity(entity);\n        // we do not want to update creating unil after creation is completed\n        this._creating.set(i, undefined);\n      }\n    }\n  }\n\n  /**\n   * request the scheduler to run all registered systems\n   */\n  runSystems(): void {\n    this.scheduler.runSystems();\n    this.runQuerySystems();\n  }\n\n  /**\n   * take all registered systems and schedule them\n   */\n  scheduleSystems(): void {\n    this.scheduler.systems = this.systemManager.systems;\n    this.scheduler.sortSystems();\n  }\n\n  /**\n   * notify any reactive systems that utilize this component to process\n   * the owning entity during its next processing cycle\n   * @param component the component to notify systems about\n   * @param ignoredSystems the systems this update should ignore\n   */\n  update(component: Component, ignoredSystems: number[] = []): void {\n    if (!this._updating.has(component.owner))\n      this._updating.set(component.owner, new Bag<SmartUpdate>());\n    const data = this._updating.get(component.owner);\n    if (data) {\n      const smartUpdate = data.get(component.type);\n      let ignored: boolean[] = [];\n      if (smartUpdate) {\n        ignored = smartUpdate[1];\n      }\n      for (let i = ignoredSystems.length; i--; ) {\n        ignored[ignoredSystems[i]] = true;\n      }\n      data.set(component.type, [component, ignored]);\n    }\n  }\n\n  /**\n   * notify any reactive systems any entities with the given component type should\n   * be processed\n   * @param entity which owns the component\n   * @param componentType the component type to notify systems about\n   * @param ignoredSystems the systems this update should ignore\n   */\n  updateComponent(\n    entity: Entity,\n    componentType: typeof Component,\n    ignoredSystems: number[] = []\n  ) {\n    const maybeComponent = this.getComponent(entity, componentType);\n    if (maybeComponent) {\n      this.update(maybeComponent, ignoredSystems);\n    }\n  }\n\n  /**\n   * notify any reactive systems that utilize these components to\n   * process the owning entity during its next processing cycle\n   * @param components the components to notify systems about\n   * @param ignoredSystems the systems this update should ignore\n   */\n  updateAll(components: Component[], ignoredSystems: number[] = []): void {\n    for (let i = components.length; i--; ) {\n      this.update(components[i], ignoredSystems);\n    }\n  }\n\n  /**\n   * notify any reactive systems to process this entity,\n   * if its components satisfy their queries\n   * @param entity\n   */\n  updateByEntity(entity: Entity): void {\n    this._updatingEntities.push(entity);\n  }\n\n  updateByEntities(entities: Entity[]): void {\n    this._updatingEntities = this._updatingEntities.concat(entities);\n  }\n\n  /**\n   * update the internal ecs instance timing information with the current time\n   * @param time current time in miliseconds\n   */\n  updateTime(time: number): void {\n    this._delta = (time - this._lastTime) / 1000;\n    this._elapsed += this._delta;\n    this._lastTime = time;\n  }\n\n  /**\n   * update the internal ecs instance timing information with a delta time\n   * @param delta the time delta since the ecs instance was last updated\n   */\n  updateByDelta(delta: number): void {\n    this._delta = delta;\n    this._elapsed += this._delta;\n    this._lastTime = performance.now();\n  }\n\n  destroy(): void {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      this.cleanUp();\n    }\n  }\n\n  reset(): void {\n    this.systemManager.reset();\n    this.componentManager.reset();\n    this.tagManager.cleanUp();\n    this.groupManager.cleanUp();\n    this.entityManager.reset();\n  }\n\n  /**\n   * tell the ecs instance to cleanup everything\n   */\n  cleanUp(): void {\n    this.systemManager.cleanUp();\n    this.componentManager.cleanUp();\n    this.groupManager.cleanUp();\n    this.tagManager.cleanUp();\n    this.entityManager.cleanUp();\n    this.scheduler.cleanUp();\n  }\n\n  _joiner<\n    T extends ComponentTuple,\n    V extends ComponentTuple,\n    W extends ComponentTuple\n  >(\n    entity: Entity,\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): Option<JoinedResult<T, V>> {\n    const id = entity.id;\n    let valid = true;\n    const result: unknown[] = [];\n\n    if (unwanted) {\n      for (let j = unwanted ? unwanted.length : 0; j--; ) {\n        if (this.hasComponentById(id, unwanted[j].type)) {\n          valid = false;\n          break;\n        }\n      }\n\n      if (!valid) return null;\n    }\n\n    if (needed) {\n      for (let j = 0; j < needed.length; j++) {\n        const gotComponents = this.componentManager.components.get(\n          needed[j].type\n        );\n        const value = gotComponents ? gotComponents.get(id) : undefined;\n        valid = (value && valid) as boolean;\n        if (!valid) break;\n        result.push(value);\n      }\n\n      if (!valid) return null;\n    }\n\n    if (optional) {\n      for (let j = 0; j < optional.length; j++) {\n        const gotComponents = this.componentManager.components.get(\n          optional[j].type\n        );\n        const value = gotComponents ? gotComponents.get(id) : undefined;\n        result.push(value);\n      }\n    }\n\n    if (valid) return [result, entity] as JoinedResult<T, V>;\n    return null;\n  }\n\n  *join<\n    T extends ComponentTuple,\n    V extends ComponentTuple,\n    W extends ComponentTuple\n  >(\n    entities: Entity[],\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    //   [components: [...OrderedTuple<T>, ...OrderedTuple<V>], entity: Entity]\n    // > {\n    for (let i = entities.length; i--; ) {\n      const entity = entities[i];\n      const id = entity.id;\n      let valid = true;\n      const result: unknown[] = [];\n\n      if (unwanted) {\n        for (let j = unwanted ? unwanted.length : 0; j--; ) {\n          if (this.hasComponentById(id, unwanted[j].type)) {\n            valid = false;\n            break;\n          }\n        }\n\n        if (!valid) continue;\n      }\n\n      if (needed) {\n        for (let j = 0; j < needed.length; j++) {\n          const gotComponents = this.componentManager.components.get(\n            needed[j].type\n          );\n          const value = gotComponents ? gotComponents.get(id) : undefined;\n          valid = (value && valid) as boolean;\n          if (!valid) break;\n          result.push(value);\n        }\n\n        if (!valid) continue;\n      }\n\n      if (optional) {\n        for (let j = 0; j < optional.length; j++) {\n          const gotComponents = this.componentManager.components.get(\n            optional[j].type\n          );\n          const value = gotComponents ? gotComponents.get(id) : undefined;\n          result.push(value);\n        }\n      }\n\n      if (valid) yield [result, entity] as JoinedResult<T, V>;\n      // [\n      //     components: [...OrderedTuple<T>, ...OrderedTuple<V>],\n      //     entity: Entity\n      //   ];\n    }\n    return;\n  }\n\n  *joinByBag<\n    T extends ComponentTuple,\n    V extends ComponentTuple,\n    W extends ComponentTuple\n  >(\n    bag: Bag<Entity>,\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    for (let i = bag.length; i--; ) {\n      const entity = bag.get(i);\n      if (!entity) continue;\n      const valid = this._joiner(entity, needed, optional, unwanted);\n      if (!valid) continue;\n      yield valid;\n    }\n    return;\n  }\n\n  *joinByComponentBag<\n    T extends ComponentTuple,\n    V extends ComponentTuple,\n    W extends ComponentTuple\n  >(\n    bag: Bag<Component>,\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    for (let i = bag.length; i--; ) {\n      const component = bag.get(i);\n      if (!component) continue;\n      const entity = this.getEntity(component.owner);\n      if (!entity) continue;\n      const valid = this._joiner(entity, needed, optional, unwanted);\n      if (!valid) continue;\n      yield valid;\n    }\n    return;\n  }\n\n  *joinByGroup<\n    T extends ComponentTuple,\n    V extends ComponentTuple,\n    W extends ComponentTuple\n  >(\n    group: string,\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    const bag = this.groupManager.getGroup(group);\n    if (!bag) return [];\n    yield* this.joinByBag(bag, needed, optional, unwanted);\n  }\n\n  *joinById<\n    T extends ComponentTuple,\n    V extends ComponentTuple,\n    W extends ComponentTuple\n  >(\n    ids: number[],\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    //   [components: [...OrderedTuple<T>, ...OrderedTuple<V>], entity: Entity]\n    // > {\n    for (let i = ids.length; i--; ) {\n      const id = ids[i];\n      const entity = this.getEntity(id);\n      if (!entity) continue;\n      let valid = true;\n      const result: Option<Component>[] = [];\n\n      if (unwanted) {\n        for (let j = unwanted ? unwanted.length : 0; j--; ) {\n          if (this.hasComponentById(id, unwanted[j].type)) {\n            valid = false;\n            break;\n          }\n        }\n\n        if (!valid) continue;\n      }\n\n      if (needed) {\n        for (let j = 0; j < needed.length; j++) {\n          const gotComponents = this.componentManager.components.get(\n            needed[j].type\n          );\n          const value = gotComponents ? gotComponents.get(id) : null;\n          valid = (value && valid) as boolean;\n          if (!valid || is_none(value)) break;\n          result.push(value);\n        }\n\n        if (!valid) continue;\n      }\n\n      if (optional) {\n        for (let j = 0; j < optional.length; j++) {\n          const gotComponents = this.componentManager.components.get(\n            optional[j].type\n          );\n          const value = gotComponents ? gotComponents.get(id) : null;\n          result.push(value);\n        }\n      }\n\n      if (valid) yield [result, entity] as JoinedResult<T, V>;\n      // as [\n      //     [...OrderedTuple<T>, ...OrderedTuple<V>],\n      //     Entity\n      //   ];\n    }\n    return;\n  }\n\n  *joinByTag<\n    T extends ComponentTuple,\n    V extends ComponentTuple,\n    W extends ComponentTuple\n  >(\n    tags: string[],\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    for (let i = tags.length; i--; ) {\n      const tag = tags[i];\n      const entity = this.tagManager.getEntityByTag(tag);\n      if (!entity) continue;\n      let valid = true;\n      const result: unknown[] = [];\n\n      if (unwanted) {\n        for (let j = unwanted ? unwanted.length : 0; j--; ) {\n          if (this.hasComponent(entity, unwanted[j].type)) {\n            valid = false;\n            break;\n          }\n        }\n\n        if (!valid) continue;\n      }\n\n      if (needed) {\n        for (let j = 0; j < needed.length; j++) {\n          const gotComponents = this.componentManager.components.get(\n            needed[j].type\n          );\n          const value = gotComponents ? gotComponents.get(entity.id) : null;\n          valid = (value && valid) as boolean;\n          if (!valid) break;\n          result.push(value);\n        }\n\n        if (!valid) continue;\n      }\n\n      if (optional) {\n        for (let j = 0; j < optional.length; j++) {\n          const gotComponents = this.componentManager.components.get(\n            optional[j].type\n          );\n          const value = gotComponents ? gotComponents.get(entity.id) : null;\n          result.push(value);\n        }\n      }\n\n      if (valid) yield [result, entity] as JoinedResult<T, V>;\n    }\n    return;\n  }\n\n  /**\n   *\n   */\n  *joinAll<\n    T extends ComponentTuple,\n    V extends ComponentOptionTuple,\n    W extends ComponentTuple\n  >(\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    for (let i = this.entityManager.entities.length; i--; ) {\n      const entity = this.entityManager.entities.get(i);\n      if (!entity) continue;\n      let valid = true;\n      const result: Option<Component>[] = [];\n\n      if (unwanted) {\n        for (let j = unwanted ? unwanted.length : 0; j--; ) {\n          if (this.hasComponentById(i, unwanted[j].type)) {\n            valid = false;\n            break;\n          }\n        }\n\n        if (!valid) continue;\n      }\n\n      if (needed) {\n        for (let j = 0; j < needed.length; j++) {\n          const gotComponents = this.componentManager.components.get(\n            needed[j].type\n          );\n          if (gotComponents) {\n            const value = gotComponents.get(i);\n            if (value && valid) {\n              result.push(value);\n              continue;\n            } else {\n              valid = false;\n              break;\n            }\n          } else {\n            valid = false;\n            break;\n          }\n        }\n\n        if (!valid) continue;\n      }\n\n      if (optional) {\n        for (let j = 0; j < optional.length; j++) {\n          const compType = optional[j];\n          if (is_none(compType)) continue;\n          const gotComponents = this.componentManager.components.get(\n            compType.type\n          );\n          if (is_none(gotComponents)) continue;\n          const value = gotComponents.get(i);\n          result.push(value);\n        }\n      }\n\n      if (valid) yield [result, entity] as JoinedResult<T, V>;\n    }\n    return;\n  }\n\n  *joinBySet<\n    T extends ComponentTuple,\n    V extends ComponentTuple,\n    W extends ComponentTuple\n  >(\n    set: Set<Entity>,\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    for (const entity of set) {\n      const value = this._joiner(entity, needed, optional, unwanted);\n      if (value) {\n        yield value;\n      }\n    }\n  }\n\n  *joinByComponentSet<\n    T extends ComponentTuple,\n    V extends ComponentTuple,\n    W extends ComponentTuple\n  >(\n    set: Set<Component>,\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    for (const component of set) {\n      const entity = this.getEntity(component.owner);\n      if (!entity) continue;\n      const value = this._joiner(entity, needed, optional, unwanted);\n      if (!value) continue;\n      yield value;\n    }\n  }\n\n  retrieve<T extends ComponentTuple, V extends ComponentOptionTuple>(\n    entity: Entity,\n    components: [...T, ...V]\n  ): JoinedData<T, V> {\n    const results: Option<Component>[] = [];\n\n    for (let i = 0; i < components.length; i++) {\n      const compType = components[i];\n      if (is_none(compType)) continue;\n      const gotComponents = this.componentManager.components.get(compType.type);\n      if (is_none(gotComponents)) continue;\n      const value = gotComponents.get(entity.id);\n      results.push(value);\n    }\n\n    return results as JoinedData<T, V>;\n  }\n\n  retrieveById<T extends ComponentTuple, V extends ComponentOptionTuple>(\n    id: number,\n    components: [...T, ...V]\n  ): JoinedData<T, V> {\n    const results: Option<Component>[] = [];\n\n    for (let i = 0; i < components.length; i++) {\n      const compType = components[i];\n      if (is_none(compType)) continue;\n      const gotComponents = this.componentManager.components.get(compType.type);\n      if (is_none(gotComponents)) continue;\n      const value = gotComponents.get(id);\n      results.push(value);\n    }\n\n    return results as JoinedData<T, V>;\n  }\n\n  retrieveByTag<T extends ComponentTuple>(\n    tag: string,\n    components: [...T]\n  ): OrderedComponentOptionTuple<T> {\n    const results: Option<Component>[] = [];\n    const entity = this.getEntityByTag(tag);\n    if (!entity) return results as OrderedComponentOptionTuple<T>;\n\n    for (let j = 0; j < components.length; j++) {\n      const gotComponents = this.componentManager.components.get(\n        components[j].type\n      );\n      const value = gotComponents ? gotComponents.get(entity.id) : undefined;\n      results.push(value);\n    }\n\n    return results as OrderedComponentOptionTuple<T>;\n  }\n\n  *query<T extends ComponentTuple>(\n    needed: T\n  ): IterableIterator<OrderedComponentTuple<T>> {\n    for (let i = this.entityManager.entities.length; i--; ) {\n      const entity = this.entityManager.entities.get(i);\n      if (!entity) continue;\n      let valid = true;\n      const result: OrderedComponentTuple<T> = [] as OrderedComponentTuple<T>;\n      for (let j = 0; j < needed.length; j++) {\n        const components = this.componentManager.components.get(needed[j].type);\n        if (components) {\n          const component = components.get(i);\n          if (is_none(component)) {\n            valid = false;\n            break;\n          }\n          valid = !!component && valid;\n          if (!valid) break;\n          result.push(component);\n        }\n      }\n      if (valid) yield result; // as OptionTuple<T>;\n    }\n    return;\n  }\n\n  qSysTuple: [\n    func: (params: {\n      query: FuncQuery<any>;\n      ecs: EcsInstance;\n      delta: number;\n    }) => void,\n    data: ComponentTuple\n  ][] = [];\n\n  withSystem<T extends ComponentTuple>(\n    data: [...T],\n    queryFunc: QueryFunc<T>\n  ): void {\n    this.qSysTuple.push([queryFunc, data]);\n  }\n\n  runQuerySystems(): void {\n    for (let i = 0; i < this.qSysTuple.length; i++) {\n      const [func, data] = this.qSysTuple[i];\n      timer.begin();\n      func({\n        query: new FuncQuery(this, data),\n        ecs: this,\n        delta: this._delta,\n      });\n      timer.end('query system::', [...data]);\n    }\n  }\n}\n", "import { Bag } from './Bag';\nimport { EcsInstance } from './EcsInstance';\nimport { Component } from './Component';\nimport { Entity } from './Entity';\nimport type {\n  ComponentOptionTuple,\n  ComponentTuple,\n  JoinedData,\n  JoinedQuery,\n  JoinedResult,\n} from 'types/tuples';\n\nexport declare interface QueryArgs<\n  T extends ComponentTuple = ComponentTuple,\n  V extends ComponentOptionTuple = ComponentOptionTuple,\n  W extends ComponentTuple = ComponentTuple\n> {\n  ecsInstance: EcsInstance;\n  needed: [...T];\n  optional?: [...V];\n  unwanted?: [...W];\n}\n\nexport class Query<\n  T extends ComponentTuple = ComponentTuple,\n  V extends ComponentOptionTuple = ComponentOptionTuple,\n  W extends ComponentTuple = ComponentTuple\n> {\n  private _ecsInstance: EcsInstance;\n  private _needed: [...T];\n  private _optional: [...V];\n  private _unwanted: [...W];\n  private _data: JoinedQuery<T, V>[];\n  private _entity!: Entity;\n\n  constructor(props: QueryArgs<T, V, W>) {\n    this._ecsInstance = props.ecsInstance;\n    this._needed = props.needed;\n    this._optional = props.optional || ([] as any);\n    this._unwanted = props.unwanted || ([] as any);\n    this._data = [];\n  }\n\n  /**\n   * current needed components\n   */\n  get needed(): (typeof Component)[] {\n    return this._needed;\n  }\n\n  get data(): JoinedQuery<T, V>[] {\n    return this._data;\n  }\n\n  set entity(value: Entity) {\n    this._entity = value;\n  }\n\n  /**\n   * a very useful component retrieval function\n   * @param component - the component type to retrieve\n   * @returns the instance of that component, if any\n   */\n  get<T extends typeof Component>(component: T): InstanceType<T> {\n    return this._ecsInstance.getComponent(\n      this._entity,\n      component\n    ) as InstanceType<T>;\n  }\n\n  resolve(entities: Bag<Entity>): void {\n    this._data = [];\n    entityLoop: for (let e = entities.length; e--; ) {\n      const entity = entities.get(e);\n      if (!entity) continue;\n      for (let i = this._unwanted.length; i--; ) {\n        if (this._ecsInstance.hasComponentOfType(entity, this._unwanted[i]))\n          continue entityLoop;\n      }\n      const components: any[] = [];\n      // for the following for-loops, order maters\n      for (let i = 0; i < this._needed.length; i++) {\n        const component = this._ecsInstance.getComponent(\n          entity,\n          this._needed[i]\n        );\n        if (!component) continue entityLoop;\n        components.push(component);\n      }\n\n      for (let i = 0; i < this._optional.length; i++) {\n        const component = this._ecsInstance.getComponent(\n          entity,\n          this._optional[i]\n        );\n        components.push(component);\n      }\n      this._data.push([components, entity] as JoinedQuery<T, V>);\n    }\n  }\n\n  /**\n   * does the given entity have an unwanted component\n   * @param entity the entity to check\n   * @returns 'true' if an unwanted component was found\n   */\n  isInvalid(entity: Entity): boolean {\n    for (let i = this._unwanted.length; i--; ) {\n      if (this._ecsInstance.hasComponent(entity, this._unwanted[i].type))\n        return true;\n    }\n    return false;\n  }\n\n  /**\n   * does the given entity, found by its id, have an unwanted component\n   * @param id the id of the entity to check\n   * @returns 'true' if an unwanted component was found\n   */\n  isInvalidById(id: number): boolean {\n    for (let i = this._unwanted.length; i--; ) {\n      if (this._ecsInstance.hasComponentById(id, this._unwanted[i].type))\n        return true;\n    }\n    return false;\n  }\n\n  isNeededComponent(component: Component): boolean {\n    return this._needed.includes(component.constructor as typeof Component);\n  }\n\n  /**\n   * does the entity contain every component required by the query\n   * @param entity the entity to check\n   * @returns 'true' if all required components were found\n   */\n  isValid(entity: Entity): boolean {\n    for (let i = this._needed.length; i--; ) {\n      if (!this._ecsInstance.hasComponent(entity, this._needed[i].type))\n        return false;\n    }\n    return true;\n  }\n\n  /**\n   * does the entity, found by its id, contain every component required by the query\n   * @param id the id of the entity to check\n   * @returns 'true' if all required components were found\n   */\n  isValidById(id: number): boolean {\n    for (let i = this._needed.length; i--; ) {\n      if (!this._ecsInstance.hasComponentById(id, this._needed[i].type))\n        return false;\n    }\n    return true;\n  }\n\n  isOptional(entity: Entity): boolean {\n    for (let i = this._optional.length; i--; ) {\n      if (\n        this._optional[i] &&\n        this._ecsInstance.hasComponent(entity, this._optional[i].type)\n      )\n        return true;\n    }\n    return false;\n  }\n\n  isOptionalById(id: number): boolean {\n    for (let i = this._optional.length; i--; ) {\n      if (this._ecsInstance.hasComponentById(id, this._optional[i].type))\n        return true;\n    }\n    return false;\n  }\n\n  /**\n   * checks if the given component is valid for this query\n   * @param component the component to check\n   * @returns `true` if valid, `false` if not\n   */\n  isValidComponent(component: Component): boolean {\n    // IDEA: use bags instead of Arrays or maybe both depending on context\n    //       this will give us O(1) validity checks\n    return (\n      this._needed.includes(component.constructor as typeof Component) ||\n      this._optional.includes(component.constructor as typeof Component)\n    );\n  }\n\n  join<\n    T extends (typeof Component)[],\n    V extends (typeof Component)[],\n    W extends (typeof Component)[]\n  >(\n    entities: Entity[],\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    return this._ecsInstance.join(entities, needed, optional, unwanted);\n  }\n\n  joinById<\n    T extends (typeof Component)[],\n    V extends (typeof Component)[],\n    W extends (typeof Component)[]\n  >(\n    ids: number[],\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    return this._ecsInstance.joinById(ids, needed, optional, unwanted);\n  }\n\n  joinAll<\n    T extends (typeof Component)[],\n    V extends (typeof Component)[],\n    W extends (typeof Component)[]\n  >(\n    needed?: [...T],\n    optional?: [...V],\n    unwanted?: [...W]\n  ): IterableIterator<JoinedResult<T, V>> {\n    return this._ecsInstance.joinAll(needed, optional, unwanted);\n  }\n\n  retrieve(): JoinedData<T, V> {\n    return this._ecsInstance.retrieve(this._entity, [\n      ...this._needed,\n      ...this._optional,\n    ]);\n  }\n\n  retrieveById(id: number): JoinedData<T, V> {\n    return this._ecsInstance.retrieveById(id, [\n      ...this._needed,\n      ...this._optional,\n    ]);\n  }\n\n  /**\n   * validates the given entity for this query\n   * @param entity the entity to validate\n   * @returns `true` if valid, `false` if not\n   */\n  validate(entity: Entity): boolean {\n    const valid = this.isValid(entity);\n    const invalid = this.isInvalid(entity);\n    return valid && !invalid;\n  }\n\n  /**\n   * validates the given entity id for this query\n   * @param id the id of the entity to validate\n   * @returns `true` if valid, `false` if not\n   */\n  validateById(id: number): boolean {\n    const valid = this.isValidById(id);\n    const invalid = this.isInvalidById(id);\n    return valid && !invalid;\n  }\n}\n", "import { Bag } from './Bag';\nimport { Entity } from './Entity';\nimport { EcsInstance } from './EcsInstance';\nimport { Query } from './Query';\nimport type {\n  ComponentOptionTuple,\n  ComponentTuple,\n  JoinedResult,\n  SmartUpdate,\n} from 'types/tuples';\nimport { EntitySystemArgs } from 'types/system';\n\nexport class EntitySystem<\n  T extends ComponentTuple = any,\n  Props = any,\n  V extends ComponentOptionTuple = any,\n  W extends ComponentTuple = any\n> {\n  private _id = -1;\n  private _entities: Bag<Entity> = new Bag<Entity>();\n  private _ecsInstance: EcsInstance;\n  private _priority: number;\n  private _query!: Query<T, V, W>;\n  private _active = true;\n  private _dirty = false;\n  protected reactive = false;\n  props: EntitySystemArgs<T, Props, V, W>;\n  needed!: [...T];\n  optional!: [...V]; //[...V];\n  unwanted!: [...W]; //[...W];\n\n  constructor(props: EntitySystemArgs<T, Props, V, W>) {\n    this.props = props;\n    this._id = props.id;\n    this._ecsInstance = props.ecsInstance;\n    this.reactive = props.reactive || false;\n    this._priority = props.priority || 0;\n    this.needed = props.needed;\n    this.optional = props.optional || ([] as any);\n    this.unwanted = props.unwanted || ([] as any);\n  }\n\n  get id(): number {\n    return this._id;\n  }\n\n  get ecs(): EcsInstance {\n    return this._ecsInstance;\n  }\n\n  get ecsInstance(): EcsInstance {\n    return this._ecsInstance;\n  }\n\n  set ecsInstance(value: EcsInstance) {\n    this._ecsInstance = value;\n  }\n\n  get entities(): Bag<Entity> {\n    return this._entities;\n  }\n\n  get isReactive(): boolean {\n    return this.reactive;\n  }\n\n  get priority(): number {\n    return this._priority;\n  }\n\n  get query(): Query<T, V, W> {\n    return this._query;\n  }\n\n  get active(): boolean {\n    return this._active;\n  }\n\n  get dirty(): boolean {\n    return this._dirty;\n  }\n\n  get componentTypes(): [...T, ...V, ...W] {\n    // let result: [...T,...V,...W] = this.needed;\n    // if (this.optional) {\n    //   let foo = result.concat(this.optional);\n    //   result = foo;\n    // }\n    // if (this.unwanted) {\n    //   result = result.concat(this.unwanted);\n    // }\n    return [...this.needed, ...this.optional, ...this.unwanted];\n  }\n\n  /**\n   * enable this system\n   */\n  enable(): void {\n    this._active = true;\n  }\n\n  /**\n   * disable this system\n   */\n  disable(): void {\n    this._active = false;\n  }\n\n  buildQuery(): void {\n    this._query = new Query<T, V, W>({\n      ecsInstance: this._ecsInstance,\n      needed: this.needed,\n      unwanted: this.unwanted || ([] as any),\n      optional: this.optional || ([] as any),\n    });\n  }\n\n  /**\n   * remove the given entity from this system, calling the system's removed function\n   * if successful\n   * @param entity the entity to remove\n   */\n  removeEntity(entity: Entity): void {\n    if (this._entities.has(entity.id)) {\n      this._entities.set(entity.id, undefined);\n      this.query.entity = entity;\n      this.removed?.(entity);\n      this._dirty = true;\n    }\n  }\n\n  removeEntityById(id: number): void {\n    const entity = this._entities.get(id);\n    if (entity) {\n      this._entities.set(id, undefined);\n      this.query.entity = entity;\n      this.removed?.(entity);\n      this._dirty = true;\n    }\n  }\n\n  /**\n   * creation/assignment of entities upon initial resolution\n   */\n  initialResolve(entity: Entity): void {\n    this._entities.set(entity.id, entity);\n    this.query.entity = entity;\n    this.created?.(entity);\n    this._dirty = true;\n  }\n\n  /**\n   * creation/assignment of enttiies after load\n   */\n  initialCreate(entity: Entity): void {\n    this.query.entity = entity;\n    this.created?.(entity);\n    this._dirty = true;\n  }\n\n  /**\n   * add the entity with the given id to this system\n   * @param id the id of the entity to add\n   */\n  addEntityById(id: number): void {\n    const entity = this._ecsInstance.getEntity(id);\n    if (!entity) return;\n    this.addEntity(entity);\n  }\n\n  /**\n   * add the entity to this system\n   * @param entity the entity to add\n   */\n  addEntity(entity: Entity): void {\n    if (!this._entities.has(entity.id)) {\n      this._entities.set(entity.id, entity);\n      this.query.entity = entity;\n      this.added?.(entity);\n      this._dirty = true;\n    }\n  }\n\n  createEntity(entity: Entity): void {\n    this._entities.set(entity.id, entity);\n    this.query.entity = entity;\n    this.created?.(entity);\n    this._dirty = true;\n  }\n\n  /**\n   * adds an entity without calling `added`\n   * @param id the id of the entity to add\n   */\n  addByUpdateById(id: number): void {\n    const entity = this._ecsInstance.getEntity(id);\n    if (!entity) return;\n    this.addByUpdate(entity);\n  }\n\n  /**\n   * adds an entity without calling `added`\n   * @param entity the entity to add\n   */\n  addByUpdate(entity: Entity): void {\n    this._entities.set(entity.id, entity);\n    this._dirty = true;\n  }\n\n  deleteEntity(entity: Entity): void {\n    if (this.reactive) {\n      this.query.entity = entity;\n      this.deleted?.(entity);\n      this._dirty = true;\n    } else {\n      if (this._entities.has(entity.id)) {\n        this._entities.set(entity.id, undefined);\n        this.query.entity = entity;\n        this.deleted?.(entity);\n        this._dirty = true;\n      }\n    }\n  }\n\n  /**\n   * clean this system, calling its `cleanUp` function and clearing\n   * all owned entities\n   */\n  cleanSystem(): void {\n    this.cleanUp && this.cleanUp(this._entities);\n    this._entities.clear();\n  }\n\n  /**\n   * process all entities\n   */\n  processAll(): void {\n    if (this.shouldProcess()) {\n      this.begin && this.begin();\n      this.processEntities();\n      this.processJoin();\n      this.end && this.end();\n    }\n  }\n\n  processJoin(): void {\n    if (!this.join) return;\n    // if we have no entities, don't bother running\n    if (!this._entities.count) return;\n    if (this._dirty) this.resolveQuery();\n    const data = this._query.data;\n    for (let i = data.length; i--; ) {\n      this.join(data[i]);\n    }\n  }\n\n  /**\n   * processes entities one by one calling the system's `process` function\n   * and passing the results of the systems `Query`\n   */\n  processEntities(): void {\n    if (!this.process) return;\n    // if we have no entiteis, don't bother\n    if (!this._entities.count) return;\n    // process up to the last inserted entity\n    for (let i = this._entities.length; i--; ) {\n      const entity = this._entities.get(i);\n      if (!entity) continue;\n      this._query.entity = entity;\n      this.process(entity, this._query, this._ecsInstance.delta);\n    }\n  }\n\n  /**\n   * determine whether or not this system should process\n   */\n  shouldProcess(): boolean {\n    return true;\n  }\n\n  resolveQuery() {\n    this.query.resolve(this._entities);\n    this._dirty = false;\n  }\n\n  resetSystem(): void {\n    this.reset && this.reset();\n    this._entities.clear();\n  }\n\n  updateById(id: number, updates: Bag<SmartUpdate>): void {\n    const entity = this.entities.get(id);\n    if (entity) this.updated?.(entity, updates);\n  }\n\n  update(entity: Entity): void {\n    this.updated?.(entity);\n  }\n\n  /*\n   * extendable lifecycle functions\n   */\n  initialize?(): void;\n  load?(entities: Bag<Entity>): void;\n  created?(entity: Entity): void;\n  deleted?(entity: Entity): void;\n  added?(entity: Entity): void;\n  removed?(entity: Entity): void;\n  cleanUp?(entities: Bag<Entity>): void;\n  reset?(): void;\n  begin?(): void;\n  end?(): void;\n  process?(entity: Entity, query: Query<T, V, W>, delta: number): void;\n  /**\n   * alternate to `process`, but auto-retrieves all needed/optional components\n   * for entities in a very efficient data structure. Components are returned in\n   * the exact order of the `needed` array followed by `optional` array\n   */\n  join?(result: JoinedResult<T, V>): void;\n  /**\n   * called for static systems when a given entity it owns has a component update\n   */\n  updated?(entity: Entity, updates?: Bag<SmartUpdate>): void;\n}\n"],
  "mappings": "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",
  "names": ["i"]
}
